#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <cmath>
#include <iomanip>
#include <map>

// Main operating states
enum class States
{
  Initialize, ReceiveInput, Simulate, DisplayResults, AskToContinue
};

// Structure to contain information related to a memory operation
struct MemoryOperation
{
  bool isWrite;
  int address;
  unsigned int mainMemoryBlock;
  int cacheMemorySet;
  bool isHit;
};

// Structure to contain cacheBlock information
struct CacheBlock
{
  bool isDirty;
  bool isValid = false;
  unsigned int tag;
  unsigned int mainMemoryBlock;
  int lastTimeUsed;
  int timeInserted;
};

// Structure to contain data obtained from user
struct InputData
{
  int mainMemSize_bytes;
  int cacheSize_bytes;
  int blockSize_bytes;
  int setAssociativityDegree;
  std::string replacementPolicy;
  std::string inputFileName;
};

// Structure to contain output data from simulator
struct SimulatorOutput
{
  std::vector<MemoryOperation> operations;
  std::vector<CacheBlock> cache;
  int totalAddressBits;
  int offsetBits;
  int indexBits;
  int tagBits;
  int cacheSizeRequired;
  int totalAccesses;
  int bestHits;
  int actualHits;
  float bestHitRate;
  float actualHitRate;
};

// Prompts user for input on the console and returns prompted data
InputData getUserInput()
{
  InputData inputData;

  std::cout << "Enter the size of main memory in bytes: ";
  std::cin >> inputData.mainMemSize_bytes;
  std::cout << "Enter the size of the cache in bytes: ";
  std::cin >> inputData.cacheSize_bytes;
  std::cout << "Enter the cache block/line size: ";
  std::cin >> inputData.blockSize_bytes;
  std::cout << "Enter the degree of set-associativity (input n for an n-way set-associative mapping): ";
  std::cin >> inputData.setAssociativityDegree;
  std::cout << "Enter the replacement policy (L = LRU, F = FIFO): ";
  std::cin >> inputData.replacementPolicy;
  std::cout << "Enter the name of the input file containing the list of memory references generated by the CPU: ";
  std::cin >> inputData.inputFileName;

  return inputData;
}

// Reads file filename and builds a vector of operations to be performed in the simulation
std::vector<MemoryOperation> readOperationsFile(const std::string& filename)
{
  std::ifstream inFile(filename);
  if (inFile.is_open())
  {
    std::vector<MemoryOperation> operations;
    std::string buf;

    std::getline(inFile, buf);
    std::cout << "\nFile has " << buf << " operations\n" << std::endl;

    std::getline(inFile, buf);
    while (std::getline(inFile, buf))
    {
      MemoryOperation operation;

      std::string operationType = buf.substr(0, 1);
      buf.erase(0, 2);

      if (operationType == "W")
      {
        operation.isWrite = true;
      }
      else if (operationType == "R")
      {
        operation.isWrite = false;
      }
      else
      {
        std::cerr << "Invalid operation type in file" << std::endl;
        exit(1);
      }

      operation.address = std::stoi(buf);
      operations.push_back(operation);
    }
    return operations;
  }
  else
  {
    std::cerr << "Error opening file: " << filename << std::endl;
    exit(1);
  }
}

// Simulates memory system with given parameters and vector of operations
SimulatorOutput simulate(std::vector<MemoryOperation> operations,
                         const int mainMemorySize_bytes,
                         const int cacheSize_bytes,
                         const int blockSize_bytes,
                         const int setAssociativityDegree,
                         const std::string replacementPolicy)
{
  std::vector<CacheBlock> cache;

  const int cacheBlocks = cacheSize_bytes / blockSize_bytes;
  const int totalAddressBits = std::log2(mainMemorySize_bytes);
  const int offsetBits = std::log2(blockSize_bytes);
  const int indexBits = std::log2(cacheBlocks / setAssociativityDegree);
  const int tagBits = totalAddressBits - offsetBits - indexBits;
  const int totalCacheSize_bytes = ((cacheSize_bytes * 8) + (tagBits * cacheBlocks) + (2 * cacheBlocks)) / 8;

  cache.resize(cacheBlocks);

  int t = 0;
  for (auto& operation : operations)
  {
    operation.mainMemoryBlock = operation.address / blockSize_bytes;
    operation.cacheMemorySet = operation.mainMemoryBlock % (cacheBlocks / setAssociativityDegree);
    const unsigned int
        tag = (operation.address >> (offsetBits + indexBits)) & static_cast<unsigned int>(std::pow(2, tagBits) - 1);

    bool done = false;
    int offset = 0;
    while (!done && offset < setAssociativityDegree)
    {
      auto& currentCacheBlock = cache.at(operation.cacheMemorySet * setAssociativityDegree + offset);
      // if cache block is valid
      if (currentCacheBlock.isValid)
      {
        if (currentCacheBlock.mainMemoryBlock == operation.mainMemoryBlock)
        {
          operation.isHit = true;
          if (operation.isWrite)
          {
            currentCacheBlock.isDirty = true;
          }

          currentCacheBlock.lastTimeUsed = t;
          done = true;
        }
      }
      else // cache block is not valid, write to it
      {
        operation.isHit = false;

        currentCacheBlock.isValid = true;
        currentCacheBlock.mainMemoryBlock = operation.mainMemoryBlock;
        currentCacheBlock.lastTimeUsed = t;
        currentCacheBlock.timeInserted = t;
        currentCacheBlock.tag = tag;
        currentCacheBlock.isDirty = operation.isWrite;

        done = true;
      }
      ++offset;
    }
    if (!done)
    {
      int index = -1;
      int lowestTime = INT32_MAX;
      if (replacementPolicy == "L") // Least Recently Used
      {
        for (int i = operation.cacheMemorySet * setAssociativityDegree;
             i < operation.cacheMemorySet * setAssociativityDegree + setAssociativityDegree; ++i)
        {
          auto& cacheBlock = cache.at(i);
          if (cacheBlock.isValid && cacheBlock.lastTimeUsed < lowestTime)
          {
            lowestTime = cacheBlock.lastTimeUsed;
            index = i;
          }
        }
      }
      else if (replacementPolicy == "F")
      {
        for (int i = operation.cacheMemorySet * setAssociativityDegree;
             i < operation.cacheMemorySet * setAssociativityDegree + setAssociativityDegree; ++i)
        {
          auto& cacheBlock = cache.at(i);
          if (cacheBlock.timeInserted < lowestTime)
          {
            lowestTime = cacheBlock.timeInserted;
            index = i;
          }
        }
      }

      auto& cacheBlock = cache.at(index);
      operation.isHit = false;
      cacheBlock.isValid = true;
      cacheBlock.mainMemoryBlock = operation.mainMemoryBlock;
      cacheBlock.tag = tag;
      cacheBlock.lastTimeUsed = t;
      cacheBlock.timeInserted = t;
      cacheBlock.isDirty = operation.isWrite;
    }
    ++t;
  }

  int bestHits = 0;
  int actualHits = 0;
  int totalAccesses = 0;
  std::map<int, int> blockAccesses;
  for (const auto& operation : operations)
  {
    if (operation.isHit)
    {
      actualHits++;
    }

    if (blockAccesses.count(operation.mainMemoryBlock) == 0)
    {
      blockAccesses[operation.mainMemoryBlock] = 1;
    }
    else
    {
      blockAccesses[operation.mainMemoryBlock]++;
    }
  }
  for (const auto& block : blockAccesses)
  {
    const int count = block.second;
    if (count > 1)
    {
      totalAccesses += count;
      bestHits += count - 1;
    }
    else
    {
      totalAccesses += count;
    }
  }
  const float bestHitRate = static_cast<float>(bestHits) / static_cast<float>(totalAccesses) * 100;
  const float actualHitRate = static_cast<float>(actualHits) / static_cast<float>(totalAccesses) * 100;

  return {operations, cache, totalAddressBits, offsetBits, indexBits, tagBits, totalCacheSize_bytes, totalAccesses,
          bestHits, actualHits, bestHitRate, actualHitRate};
}

std::string convertTagToBinaryString(const unsigned int tag, const int numBits)
{
  std::string outputString;
  for (int i = numBits - 1; i >= 0; i--)
  {
    outputString += std::to_string((tag >> i) & 0x1U);
  }
  return outputString;
}

void displayResults(const InputData& input, const SimulatorOutput& output)
{
  std::cout << "Total address lines required = " << output.totalAddressBits << std::endl
            << "Number of bits for offset = " << output.offsetBits << std::endl
            << "Number of bits for index = " << output.indexBits << std::endl
            << "Number of bits for tag = " << output.tagBits << std::endl
            << "Total cache size required = " << output.cacheSizeRequired << " bytes" << std::endl
            << std::endl;

  std::cout << std::setw(30) << std::left << "Main Memory Address"
            << std::setw(20) << std::left << "MM Blk #"
            << std::setw(20) << std::left << "CM Set #"
            << std::setw(20) << std::left << "CM Blk #"
            << std::setw(10) << std::left << "hit/miss"
            << std::endl;

  for (int i = 0; i < 100; ++i)
  {
    std::cout << "_";
  }
  std::cout << std::endl;

  for (auto& operation : output.operations)
  {
    std::string isHitString;
    if (operation.isHit)
    {
      isHitString = "hit";
    }
    else
    {
      isHitString = "miss";
    }

    std::string cacheBlockString;
    const int setAssociativityDegree = input.setAssociativityDegree;
    const int cacheBlockStart = operation.cacheMemorySet * setAssociativityDegree;

    if (setAssociativityDegree > 1)
    {
      cacheBlockString =
          std::to_string(cacheBlockStart) + " - " + std::to_string(cacheBlockStart + setAssociativityDegree - 1);
    }
    else
    {
      cacheBlockString = std::to_string(cacheBlockStart);
    }

    std::cout << std::setw(6) << " "
              << std::setw(27) << std::left << operation.address
              << std::setw(20) << std::left << operation.mainMemoryBlock
              << std::setw(18) << std::left << operation.cacheMemorySet
              << std::setw(20) << std::left << cacheBlockString
              << std::setw(10) << std::left << isHitString
              << std::endl;
  }

  std::cout << std::endl
            << "Highest possible hit rate = " << output.bestHits << "/" << output.totalAccesses << " "
            << output.bestHitRate << "%" << std::endl;

  std::cout << "Actual hit rate = " << output.actualHits << "/" << output.totalAccesses << " "
            << output.actualHitRate << "%" << std::endl;

  std::cout << std::endl
            << std::setw(30) << std::left << "Cache blk #"
            << std::setw(20) << std::left << "Dirty bit"
            << std::setw(20) << std::left << "Valid Bit"
            << std::setw(20) << std::left << "Tag"
            << std::setw(20) << std::left << "Data"
            << std::endl;
  for (int i = 0; i < 100; ++i)
  {
    std::cout << "_";
  }
  std::cout << std::endl;

  int cacheBlkNum = 0;
  for (const auto& cacheBlock : output.cache)
  {
    std::string tagString;
    std::string dataString;
    if (cacheBlock.isValid)
    {
      tagString = convertTagToBinaryString(cacheBlock.tag, output.tagBits);
      dataString = "MM Blk # " + std::to_string(cacheBlock.mainMemoryBlock);
    }
    else
    {
      for (int i = 0; i < output.tagBits; i++)
      {
        tagString += "x";
      }
      dataString = "xxx";
    }

    std::cout << std::setw(4) << " "
              << std::setw(30) << std::left << cacheBlkNum
              << std::setw(20) << std::left << cacheBlock.isDirty
              << std::setw(16) << std::left << cacheBlock.isValid
              << std::setw(20) << std::left << tagString
              << std::setw(10) << std::left << dataString
              << std::endl;

    cacheBlkNum++;
  }
}

int main()
{
  States currentState = States::Initialize;

  // Allocate necessary objects
  InputData inputData;
  std::vector<MemoryOperation> operations;
  SimulatorOutput outputData;

  bool done = false;
  // Main execution loop
  while (!done)
  {
    // Control loop
    switch (currentState)
    {
      // Initialization state
      case States::Initialize:
      {
        currentState = States::ReceiveInput;
        break;
      }

      // State to obtain user input
      case States::ReceiveInput:
      {
        inputData = getUserInput();

        operations = readOperationsFile(inputData.inputFileName);

        currentState = States::Simulate;
        break;
      }

      // Memory simulation state
      case States::Simulate:
      {
        outputData = simulate(operations,
                              inputData.mainMemSize_bytes,
                              inputData.cacheSize_bytes,
                              inputData.blockSize_bytes,
                              inputData.setAssociativityDegree,
                              inputData.replacementPolicy);

        currentState = States::DisplayResults;
        break;
      }

      // State that displays results
      case States::DisplayResults:
      {
        displayResults(inputData, outputData);

        currentState = States::AskToContinue;
        break;
      }

      // State that asks to continue
      case States::AskToContinue:
      {
        std::string input;
        std::cout << "Continue? (y = yes, n = no): ";
        std::cin >> input;

        if (input == "y")
        {
          currentState = States::Initialize;
        }
        else if (input == "n")
        {
          done = true;
        }
        break;
      }
    }
  }
}
